---
layout: post
title: ES6 学习摘要
description: ES6 粗略的看过几次阮大叔的文章，由于ES6用得少，过段时间就忘了，因此做一下梳理，简单记录摘要
category: blog
---

## let 和 const 命令
let 和 const 都是块级作用域，不存在变量提升，也不允许重复声明。let用于声明一个块级作用域的变量，而const声明一个块级作用域的常量。[详细](http://es6.ruanyifeng.com/#docs/let)

## 变量的解构赋值
数组、对象、字符串、数值和布尔值、函数参数的解构 。[详细](http://es6.ruanyifeng.com/#docs/destructuring)

## 字符串的扩展 
ES6加强了对Unicode的支持，并且扩展了字符串对象 [详细](http://es6.ruanyifeng.com/#docs/string) 

 - 扩展了字符串与Unicode的表示，以及相关方法。
 - 字符串的遍历器接口
 - at 方法，类似 charAt 方法，能识别码点大于0xFFFF的字符
 - normalize 方法，用来将字符的不同表示方法统一为同样的形式，这称为Unicode正规化
 - includes、startsWith、endsWith 方法，是javascript中 indexOf 方法的扩展
 - repeat 方法，返回一个新字符串，表示将原字符串重复n次
 - 模板字符串
 - raw 方法，可以通过它来访问模板字符串的原始字符串
 
#### 模板字符串是增强版的字符串，用反引号 ` 标识
以下是几种主要用法

```
//普通字符串
`In JavaScript '\n' is a line-feed.`

//多行字符串（个人觉得比较实用，简化了html字符串拼接的工作量）
$('#result').append(`
  There are <b>${basket.count}</b> items
   in your basket, <em>${basket.onSale}</em>
  are on sale!
`);

//字符串中嵌入变量
let name = "Bob", time = "today";
`Hello ${name}, how are you ${time}?`

//标签模板
let a=5, b=10;
function tag(){}
tag`Hello ${a + b} world ${a * b}`; //等同于 tag(['Hello ', ' world', ''], 15, 50);
```

## 正则的扩展
RegExp构造函数、字符串的正则方法、u修饰符、y修饰符、sticky属性、flags属性、RegExp.escape() 、后行断言 [详细](http://es6.ruanyifeng.com/#docs/regex)

## 数值的扩展 
 - 二进制和八进制表示法
 - Number.isFinite() 检查一个数值是否非无穷, Number.isNaN() 检查一个值是否为NaN
 - Number.parseInt(), Number.parseFloat()
 - Number.isInteger()
 - Number.EPSILON
 - 安全整数和Number.isSafeInteger() 
 - Math对象的扩展
[详细](http://es6.ruanyifeng.com/#docs/number)

## 数组的扩展 
 - Array.from() 用于将类似数组的对象和可遍历的对象这两类转为真正的数组
 - Array.of() 用于将一组值，转换为数组
 - 数组实例的copyWithin() 
 - 数组实例的find()和findIndex()
 - 数组实例的fill()
 - 数组实例的entries()，keys()和values()
 - 数组实例的includes()
 - 数组的空位 
[详细](http://es6.ruanyifeng.com/#docs/array)

## 函数的扩展

 - 函数参数的默认值
 - rest 参数
 - 扩展运算符
 - name 属性
 - 箭头函数（注意解构与箭头函数的搭配使用）
 - 函数绑定 ::
 - 尾调用优化
[详细](http://es6.ruanyifeng.com/#docs/function)

## 对象的扩展

 - 属性和方法的简洁写法
 - 属性名表达式
 - 方法的name属性
 - Object.js() 与严格比较运算符（===）的行为基本一致
 - Object.assign() 对象的合并
 - 属性的可枚举性
 - 属性的遍历
 - `__proto__`属性，Object.setPrototypeOf()，Object.getPrototypeOf()
 - Object.values()、Object.entries()
 - 对象的扩展运算符
 - Object.getOwnPropertyDescriptors()
[详细](http://es6.ruanyifeng.com/#docs/object)

## 数据类型Symbol
Symbol，表示独一无二的值

```
let s1 = Symbol('foo');
let s2 = Symbol('foo');
s1 === s2   //fasle
```

 Symbol值不能与其他类型的值进行运算，会报错。通常 Symbol 类型的值作为对象的属性名使用，避免被覆盖。Object.getOwnPropertySymbols方法，可以获取指定对象的所有Symbol属性名。
 
#### 使用 Symbol 消除魔术字符串
 下面代码包含魔术字符串
 
```
function getArea(shape, options) {
  var area = 0;

  switch (shape) {
    case 'Triangle': // 魔术字符串
      area = .5 * options.width * options.height;
      break;
    /* ... more code ... */
  }

  return area;
}

getArea('Triangle', { width: 100, height: 100 }); // 魔术字符串
```
使用 Symbol 优化上面代码

```
const shapeType = {
  triangle: Symbol()
};

function getArea(shape, options) {
  var area = 0;
  switch (shape) {
    case shapeType.triangle:
      area = .5 * options.width * options.height;
      break;
  }
  return area;
}

getArea(shapeType.triangle, { width: 100, height: 100 });
```

#### Symbol.for() 与 Symbol.keyFor()
Symbol.for() 用于登记某个 Symbol ，如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值；Symbol.keyFor() 返回一个已登记的Symbol类型值的key。

```
var s1 = Symbol('foo');
var s2 = Symbol('foo');
console.log(s1 === s2);   //false

var sf1 = Symbol.for('foo');
var sf2 = Symbol.for('foo');
console.log(sf1 == sf2);   //true

var sk1 = Symbol.keyFor(sf1);
var sk2 = Symbol.keyFor(sf2);
console.log(sk1 === sk2);   //true
```
[详细](http://es6.ruanyifeng.com/#docs/symbol)

## Set和Map数据结构
Set 是ES6提供的集合类型，常用的几种方法

 - add() 添加某个值，返回Set结构本身
 - delete() 删除某个值，返回一个布尔值，表示删除是否成功
 - has() 返回一个布尔值，表示该值是否为Set的成员
 - clear() 清除所有成员，没有返回值
 - 遍历

WeakSet结构与Set类似，也是不重复的值的集合。它与Set有两个区别，WeakSet的成员只能是对象，而不能是其他类型的值；无法引用WeakSet的成员，WeakSet是不可遍历的。WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。

Map 是ES6提供的hash结构数据类型，常用的几种方法

 - size属性 Map结构的成员总数
 - set(key, value) set方法设置key所对应的键值，然后返回整个Map结构
 - get(key) get方法读取key对应的键值，如果找不到key，返回undefined
 - has(key) 返回一个布尔值，表示某个键是否在Map数据结构中
 - delete(key) 删除某个键，返回true。如果删除失败，返回false
 - clear() 清除所有成员，没有返回值
 - 遍历
 [详细](http://es6.ruanyifeng.com/#docs/set-map)

## Generator 函数
Generator函数是ES6提供的一种异步编程解决方案，是一个状态机，封装了多个内部状态  
形式上，Generator函数是一个普通函数，但是有两个特征。一是，function命令与函数名之间有一个星号；二是，函数体内部使用yield语句，定义不同的内部状态

```
function* helloWorldGenerator() {
  yield 'hello';
  yield 'world';
  return 'ending';
}
var hw = helloWorldGenerator();
console.log(hw.next());   //{ value: 'hello', done: false }
console.log(hw.next());   //{ value: 'world', done: false }
console.log(hw.next());   //{ value: 'ending', done: true }
console.log(hw.next());   //{ value: undefined, done: true }
```
第一次调用，Generator函数开始执行，直到遇到第一个yield语句为止。next方法返回一个对象，它的value属性就是当前yield语句的值hello，done属性的值false，表示遍历还没有结束。第二次调用，Generator函数从上次yield语句停下的地方，一直执行到下一个yield语句。后面依次类推。

在一个Generator函数里面执行另一个Generator函数，我们需要用yield*语句，表明它返回的是一个遍历器对象

```
function* anotherGenerator(i) {
  yield i + 1;
  yield i + 2;
  yield i + 3;
}
function* generator(i){
  yield i;
  yield* anotherGenerator(i);
  yield i + 10;
}
var gen = generator(10);
console.log(gen.next().value);   // 10
console.log(gen.next().value);   // 11
console.log(gen.next().value);   // 12
console.log(gen.next().value);   // 13
console.log(gen.next().value);   // 20
```
[详细](http://es6.ruanyifeng.com/#docs/generator)

## Promise对象  
Promise是异步编程的一种解决方案  

- 对象的状态不受外界影响，只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。  
- 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。

基本用法  

```
var promise = new Promise(function(resolve, reject) {
  // ... some code
 
  if (/* 异步操作成功 */){
    resolve(value);
  } else {
    reject(error);
  }
});

//测试 resolve; 假如 resolve(1);
promise.then(function(value) {
  console.log(value);   // 1
  return value + 3;
}).then(function(value) {
  console.log(value);   // 4
});

//测试 异常; resolve('成功！')
promise.then(function(value) {
  console.log(value);   // 成功!
  throw "异常!";
}).catch(function(e) {
  console.log(e);   // 异常!
});

//测试 reject; 假如 reject('失败')
promise.then(function(value) {
  console.log(value);  //没有输出
}, function(error) {
  console.log(error);   //失败
});

// Promise.all 方法用于将多个Promise实例，包装成一个新的Promise实例(返回的每个成员都是Promise实例)
var promise = Promise.resolve(3);
Promise.all([true, promise, 'chen'])
       .then(values => {
           console.log(values); // [ true, 3, 'chen' ] ; 'chen' 不是Promise对象的实例，先调用Promise.resolve再进一步处理
        });
```
Promise.race() 这个Promise根据传入的Promise中的第一个确定状态--不管是接受还是拒绝--的状态而确定状态。

```
var promise1 = new Promise(function(resolve, reject) { 
    setTimeout(resolve, 500, "one"); 
});
var promise2 = new Promise(function(resolve, reject) { 
    setTimeout(resolve, 200, "two"); 
});
Promise.race([promise1, promise2]).then(function(value) {
  console.log(value); // two ; promise2先resolve
});
```
[详细](http://es6.ruanyifeng.com/#docs/promise)

## Class    
基本用法  

```
'use strict';
class Animal { 
  constructor(name) {
    this.name = name;
  }
 
  speak() {
    console.log(this.name + ' makes a noise.');
  }

  static bite() {
    console.log('bite ...');
  }
}
 
class Dog extends Animal {
  speak() {
    console.log(this.name + ' barks.');
  }
}

Animal.bite();  //bite ...
var dog = new Dog('NiNi');
dog.speak();   //NiNi barks.
```
[详细](http://es6.ruanyifeng.com/#docs/class)

## ES6 Module
在ES6之前，社区制定了一些模块加载方案，最主要的有CommonJS和AMD两种  
ES6模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD模块，都只能在运行时确定这些东西。

AMD规范的 requirejs 使用模块的方式

```
//content.js
define('content.js', function(){
    return 'A cat';
});

//index.js
require(['./content.js'], function(animal){
    console.log(animal);   //A cat
});
```

nodejs默认支持的CommonJS 使用模块的方式

```
//content.js
module.exports = {
  ...
}

//index.js
var animal = require('./content.js')
```

ES6的写法

```
//content.js
var firstName = 'Michael';
var lastName = 'Jackson';
var foo = function(){};
export {firstName, lastName, foo}

//index.js
import animal from './content'
```
[详细](http://es6.ruanyifeng.com/#docs/module)